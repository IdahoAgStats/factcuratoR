---
title: "Example of the cultivar matching process"
author: "Jacqueline Tay"
date: "`r Sys.Date()`"
output: 
rmarkdown::html_vignette:
  fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Introduction to codebook structure}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, message = FALSE}
library(factcuratoR)

codebook_folder <- here::here("tests/testthat/test_controlled_vocab")
example_folder <- here::here("inst/extdata/example_cultivar_matching")
knitroutputfolder = here::here(example_folder, "output")
auxiliary_files <- here::here(example_folder, "auxiliary_files")
```

# Read in raw variety names
```{r, results = 'asis', results.folding = 'show'}
var <- 
  read_csv(here::here(example_folder, "example_cultivar_matching.csv"), 
            col_types = cols())

knitr::kable(var)
```
# Cultivar matching 
## Create unique internal id for names
Note!: Once the fuzzymatching stage is started, it is important that the 
var_id doesn't change other it will cause problems with matching up matches
with the correct names
```{r, results = 'asis'}
names_raw <- 
  create_intid(var, 
               variety, 
               sep_aliases = "\\(", 
               crop_type, 
               nursery) %>% mutate(var_id = as.character(var_id))#, 
               #alias_col = alias)

knitr::kable(names_raw)
```
## Do exact match
The first step is to exact match to the cultivar names in the codebooks

The second step is to exact match to the names in the cv_rename.csv
```{r, results = 'asis'}
results_exactmatch <- 
  do_exactmatch(db_folder = codebook_folder,
                data_intid = names_raw,
                select_before = "2021-11-22",
                match_type = "raw")

results_rename <- 
  do_exactmatch(db_folder = codebook_folder, 
                data_intid = results_exactmatch$nomatch, 
                match_type = "raw", 
                rename_df = TRUE)

knitr::kable(results_rename[["match"]])
knitr::kable(results_rename[["nomatch"]])
```
## Do fuzzymatch
The fuzzy matching procedure returns the best fuzzymatches from
stringdist_join using several methods (e.g. "lv", "jw", "lcs"). 
See ?stringdist for more information about distance metrics.

The results are filtered for these conditions:

- crop_type must match (e.g. wheat vs. barley)

- numbers at the end of a variety name must be an exact match 
(only if there is greater than 1 digit, e.g. The trailing "1" in
"name1" would not need to match)

The results of find_fuzzymatch() are written to fuzzymatch.csv in the
directory provided by the user (via the knitroutputfolder argument)
```{r, results = 'asis', results.folding = 'show'}
output_fuzzymatch <- 
  find_fuzzymatch(results_rename$nomatch ,
                intid_col = "intid",
                select_before = "2021-05-26",
                knitroutputfolder = knitroutputfolder,
                db_folder = codebook_folder)


knitr::kable(output_fuzzymatch)
```
## Fill out the fuzzymatch.csv
Move the fuzzymatch.csv to auxiliary_files and fill out the is_truematch column.
Fill the is_truematch column with TRUE if fuzzymatch is a true match, 
otherwise fill with FALSE.

Sometimes the match may be clear, however, many names will need to be checked.

- First, start off with a Google search to determine if there are clear usages 
of both names (name in the raw data and name in the database).  This would suggest
that the names refer to different varieties and is_truematch = FALSE.

- If a Google search doesn't help clarify whether the name is a true match, 
check the possible matches with our collaborators.

- Curator can leave is_truematch blank as the subsequent steps will remind the
curator to follow up on these possible matches.

## Process fuzzymatch.csv manual matches
Read in the fuzzymatch.csv that has been manually check 
Process the file using process_fuzzymatch(), which will write out 3 files containing:

- names that still need to be checked
- names for which is_truematch = TRUE and should be added to cv_rename.csv
- names that have no match and should be standardized to add to the database

```{r, results = 'asis', results.folding = 'show'}
fuzzy_status <- 
  read_csv(
    here::here(auxiliary_files, "fuzzymatch_status.csv")) %>%
  mutate(var_id = as.character(var_id))


results_fuzzymatch <- 
  process_fuzzymatch(output_fuzzymatch_df = output_fuzzymatch, 
                     aux_fuzzy_status = fuzzy_status,
                     knitroutputfolder = knitroutputfolder)
```

## Standardize names without a match

- Move standardize_new_names.csv to auxiliary_files (append with ending e.g. "_aux")
- Go through and standardize the names in standardize_new_names_aux.csv 
by editing the column new_std_name. process_fuzzymatch() makes a first guess
by pulling the variety name for the new_std_name.
new_std_name can be changed.

It is especially important that if there are different spellings of the 
same variety, the name is standardized in this file.
e.g. If WA0061 and WA61 are the same variety, the new_std_name should be the
same for both entries.

Note: If any names are found to already be in the database, then manually
add them to the controlled_vocab/cv_rename.csv file
This occurs when the name is not found by fuzzymatching
```{r}
results_new_names <- 
  process_std_new_names(
    output_nomatch_df = results_fuzzymatch[["nomatch"]], 
    auxiliary_files = auxiliary_files,  
    filename = "standardize_new_names_aux.csv",
    knitroutputfolder = knitroutputfolder,
    db_folder = codebook_folder)

```
If the fuzzy_status file is updated (is_truematch is filled in),
re-run the entire process (in a clean session) and process_fuzzymatch() and 
process_std_new_names() will update.  The goal is:

1. get fuzzy_check.csv to be blank
2. get all of the add_to_*.csv files to be blank.  

When this has been completed, all of the variety names should be matched and
all the necessary information has been moved into the controlled vocabularies.

# Collect all the matches from each step
Once the names from the process_std_new_names() step have been added to
the cv_rename file, then they should match in the cv_rename step
```{r, results.folding = NULL, results = 'asis', eval = FALSE}
names_matches <- collect_final_matches(list(exact = results_exactmatch,
                                            rename = results_rename,
                                 fuzzy = results_fuzzymatch), names_raw)

knitr::kable(names_matches)

```
# Bind matches with the data
```{r, eval = FALSE}
# pseudocode
# data_cv_names <- left_join(data, names_matches, by = "variety)
```
