---
title: "Example of the cultivar matching process"
author: "Jacqueline Tay"
date: "`r format(Sys.Date(), '%b %d, %Y')`"
output: 
rmarkdown::html_vignette:
  fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Introduction to codebook structure}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}

---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, message = FALSE}
library(factcuratoR)

codebook_folder <- here::here("tests/testthat/test_controlled_vocab")
example_folder <- here::here("inst/extdata/example_cultivar_matching")
knitroutputfolder = here::here(example_folder, "output")
knitroutputfolder_blends = here::here(example_folder, "output_blends")
auxiliary_files <- here::here(example_folder, "auxiliary_files")
```

# Read in raw variety names
```{r, results = 'asis', results.folding = 'show'}
var <- read_csv(here::here(example_folder, "example_cultivar_matching.csv"), 
                col_types = cols())

knitr::kable(var)
```
# Cultivar matching 
## Create unique internal id for names
Extraneous information in the variety name will make the matching process more
difficult - the names won't match by exact matching and it is less certain 
that the fuzzymatching functions will be able to detect a fuzzymatch.

Some types of information that may be stored in the variety name column
that should be removed includes:
parental cross, crop type, agronomic treatments ("fill", "sprayed", etc).

Remove extraneous information stored in the raw variety column by duplicating the 
name column and removing the extraneous information (which can usually be
accomplished by regex).  The column is duplicated because the raw variety name 
should be retained to match database matches back with the data.

Additionally, if there are blends, they should be separated from the other variety
names and matched separately.  (The final formatting for blends should be:
name1;name2)

<span class="important"> Note! </span> Once the fuzzy matching stage is started, it is important that the `var_id` doesn't change other it will cause problems with matching up matches with the correct names.

```{r, results = 'asis'}
names_raw <- 
  create_intid(var, 
               variety, 
               sep_aliases = "\\(", 
               crop_type, 
               nursery) %>% mutate(var_id = as.character(var_id))#, 
               #alias_col = alias)

knitr::kable(names_raw)
```
## Do exact match
The first step is to exact match to the cultivar names in the codebooks

The second step is to exact match to the names in the cv_rename.csv
```{r, results = 'asis'}
results_exactmatch <- 
  do_exactmatch(db_folder = codebook_folder,
                data_intid = names_raw,
                select_before = "2021-11-22",
                match_type = "raw")

results_rename <- 
  do_exactmatch(db_folder = codebook_folder, 
                data_intid = results_exactmatch$nomatch, 
                match_type = "raw", 
                rename_df = TRUE)

knitr::kable(results_rename[["match"]])
knitr::kable(results_rename[["nomatch"]])
```
## Do fuzzymatch

The fuzzy matching procedure, a wrapper for `fuzzyjoin::stringdist_join()` returns the best fuzzy matches using multiple distance methods (e.g. "lv", "jw", "lcs"). 
See `??stringdist` for more information about these distance metrics.

The results are filtered for these conditions:

* The variable in `crop_type` must match (e.g. "wheat" would not match "barley")

* Numbers located at the end of a variety name or alias must be an exact match if there is more than one number present. If there is only number at the end of a variety name, the trailing digit does not need to match the rest of the name. For example "myvar1" would still match with "myvar", but "myvar123" would not. 

The results of `find_fuzzymatch(`) are written to the file *fuzzymatch.csv* in the
directory provided by the user in the `knitroutputfolder` argument. 

```{r, results = 'asis', results.folding = 'show'}
output_fuzzymatch <- 
  find_fuzzymatch(results_rename$nomatch,
                intid_col = "intid",
                select_before = "2021-05-26",
                knitroutputfolder = knitroutputfolder,
                db_folder = codebook_folder)

knitr::kable(output_fuzzymatch)
```


## Fill out the fuzzymatch.csv

Move *fuzzymatch.csv* to the helper_files/ directory and fill out the `is_truematch` column. Fill the `is_truematch` column with "TRUE" if fuzzymatch is a true match, 
otherwise fill with "FALSE".

Sometimes the match may be clear, however, many matches will need to be manually checked. Some steps for that: 

1. First, start off with a Google search to determine if there are clear usages 
of both names (name in the raw data and name in the database).  This would suggest
that the names refer to different varieties and they are not true matches.

1. If a Google search doesn't help clarify whether the name is a true match (quite likely, unfortunately), check the possible matches with our collaborators.

1. If there is no clear answer (or any answer), the curator should leave `is_truematch` blank as the subsequent steps will remind the curator to follow up on these possible matches.

## Process *fuzzymatch.csv* manual matches

1. Read in the *fuzzymatch.csv* that has been manually check
1. Process the file using `process_fuzzymatch()`, which will write out 3 files to the working directory containing:  
  * Variety names that still need to be manually checked for whether they have a match or not.
  * Variety names for which `is_truematch` is "TRUE" and should be added to *cv_rename.csv*.
  * Variety names that have no match and should be standardized to add to the database.  

```{r, results = 'asis', results.folding = 'show'}
fuzzy_status <- 
  read_csv(here::here(auxiliary_files, "fuzzymatch_status.csv")) %>%
  mutate(var_id = as.character(var_id))

results_fuzzymatch <- 
  process_fuzzymatch(output_fuzzymatch_df = output_fuzzymatch, 
                     aux_fuzzy_status = fuzzy_status,
                     knitroutputfolder = knitroutputfolder)
```

## Standardize names without a match

* Move *standardize_new_names.csv* helper_files/ directory (append file with ending "_aux")
* Go through and standardize the names in *standardize_new_names_aux.csv* 
by editing the column 'new_std_name'. The function `process_fuzzymatch()` will make an initial guess by comparing the variety name field for the `new_std_name`. The `new_std_name` can be changed [the column header?]. 

<span class="important">Note on Duplicate Names: </span> It is especially important that if there are different spellings of the same variety, the name is standardized in this file. For example, if "WA0061" and "WA61" are the same variety (spoiler: they are), the `new_std_name` should be the same for both entries.

If any variety names are already in the database, then manually add them to the *controlled_vocab/cv_rename.csv* file. This occurs when the name is not found by fuzzy matching.

```{r}
results_new_names <- 
  process_std_new_names(
    output_nomatch_df = results_fuzzymatch[["nomatch"]], 
    auxiliary_files = auxiliary_files,  
    filename = "standardize_new_names_aux.csv",
    knitroutputfolder = knitroutputfolder,
    db_folder = codebook_folder)

```
If the fuzzy_status file is updated (that is, `is_truematch` is filled in), re-run the entire process in a clean R session and `process_fuzzymatch()` and 
`process_std_new_names()` will update [the files?].  The goals are clean these files until they are empty:

1. *fuzzy_check.csv* 
1. all *add_to_{{crop_variety_name_table}}.csv* files  

When this has been completed, all of the variety names should be matched and
all the necessary information has been moved into the controlled vocabularies.

Hooray! Make sure you celebrate this achievement! 

# Collect all the matches from each step

Once the names from the `process_std_new_names()` step have been added to
the *cv_rename* file, then they should match in the cv_rename step. 

the function` collect_final_matches()` is used to collect all the matches and the stage 
where they were matched. 

```{r, results.folding = NULL, results = 'asis'}
names_matches <- 
  collect_final_matches(list(exact = results_exactmatch,
                             rename = results_rename,
                             fuzzy = results_fuzzymatch), 
                        names_raw,
                        knitroutputfolder = knitroutputfolder)

knitr::kable(names_matches)

```

# Bind matches with the data

```{r, eval = FALSE}
# do not run this code (it's here for example only)
data_cv_names <- left_join(data, names_matches, by = "variety")
```

# Special instructions for matching blends
Curate the blends separately from non-blend variety names.
Below is an example for curating blends.

```{r, results = 'asis'}
blends <- read_csv(here::here("tests/testthat/test_match_variety_files", 
                              "example_blends.csv"), 
                col_types = cols())

knitr::kable(blends)
```
## Create unique internal id for names
<span class="important"> Note! </span> For blends, set the argument
is_blends = TRUE for each of the variety matching functions.

```{r, results = 'asis'}
blends_raw <- 
  create_intid(blends, 
               variety, 
               # Although sep_alias is used to separate 
               # an alias from the variety name, it can also be used here 
               #to separate two names in a blend
               sep_aliases = "\\/", 
               crop_type,
               is_blends = TRUE) 

knitr::kable(blends_raw)
```

## Do exact matching step
```{r, results = 'asis'}
blends_exactmatch <- 
  do_exactmatch(db_folder = codebook_folder,
                data_intid = blends_raw,
                select_before = "2021-11-22",
                match_type = "raw",
                is_blends = TRUE)

knitr::kable(blends_exactmatch[["match"]])
knitr::kable(blends_exactmatch[["nomatch"]])

```
```{r, results = 'asis'}
blends_rename <- 
  do_exactmatch(db_folder = codebook_folder, 
                data_intid = blends_exactmatch$nomatch, 
                match_type = "raw", 
                rename_df = TRUE, 
                is_blends = TRUE)

knitr::kable(blends_rename[["match"]])
knitr::kable(blends_rename[["nomatch"]])

```
## Do fuzzymatching step
```{r, results = 'asis'}
blends_fuzzymatch <- 
  find_fuzzymatch(blends_rename$nomatch,
                intid_col = "intid",
                select_before = "2021-05-26",
                knitroutputfolder = knitroutputfolder_blends,
                db_folder = codebook_folder)

knitr::kable(blends_fuzzymatch)
```
## Read in and process fuzzymatches
```{r, results = 'asis'}
blends_fuzzy_status <- 
  read_csv(here::here(auxiliary_files, "fuzzymatch_blends_status.csv")) %>%
  mutate(var_id = as.character(var_id))

blends_results_fuzzymatch <- 
  process_fuzzymatch(output_fuzzymatch_df = blends_fuzzymatch, 
                     aux_fuzzy_status = blends_fuzzy_status,
                     knitroutputfolder = knitroutputfolder_blends)

```
## Collect all matches
```{r, results = 'asis'}
blends_matches <- 
  collect_final_matches(list(exact = blends_exactmatch,
                             rename = blends_rename,
                             fuzzy = blends_results_fuzzymatch), 
                        blends_raw,
                        knitroutputfolder = knitroutputfolder_blends,
                        is_blends = TRUE)

knitr::kable(blends_matches)

```
